@using AgUi.IDE.BlazorServer.Services
@using AgUi.IDE.BlazorServer.Components.Shared.Chat
@using AgUi.IDE.BlazorServer.Components.Shared.Permissions
@using AgUi.IDE.BlazorServer.Components.Shared.Tools
@using Microsoft.AspNetCore.Components.Web.Virtualization
@inject ChatService ChatService
@inject IJSRuntime JSRuntime
@implements IDisposable

<div class="chat-panel">
    <div class="chat-messages" @ref="_messagesContainer">
        @if (ChatService.Messages.Count == 0)
        {
            <div class="chat-empty-state">
                <MudIcon Icon="@Icons.Material.Filled.Chat" Size="Size.Large" Color="Color.Primary" Class="mb-4" />
                <MudText Typo="Typo.h6" Class="text-text-base mb-2">Start a Conversation</MudText>
                <MudText Class="text-text-weaker text-center" Style="max-width: 400px;">
                    Chat with the AI assistant to get help with your code.
                    Select files from the explorer to provide context.
                </MudText>
            </div>
        }
        else if (ChatService.Messages.Count > VirtualizationThreshold)
        {
            <!-- Use virtualization for large message lists -->
            <Virtualize Items="@GetMessagesWithIndex()" Context="item" ItemSize="100" OverscanCount="5" TItem="MessageWithIndex">
                <ChatMessage @key="item.Message.Id" Message="item.Message" StaggerIndex="item.Index" />
            </Virtualize>

            <!-- Show active tool executions -->
            <ToolExecutionPanel />

            <!-- Show permission requests -->
            <PermissionPanel />
        }
        else
        {
            <!-- Use regular loop for small message lists -->
            @for (var i = 0; i < ChatService.Messages.Count; i++)
            {
                var message = ChatService.Messages[i];
                var staggerIndex = i;
                <ChatMessage @key="message.Id" Message="message" StaggerIndex="staggerIndex" />
            }

            <!-- Show active tool executions -->
            <ToolExecutionPanel />

            <!-- Show permission requests -->
            <PermissionPanel />
        }
    </div>
    <ChatInput OnSend="HandleSendMessage" IsDisabled="ChatService.IsStreaming" />
</div>

@code {
    private ElementReference _messagesContainer;
    private CancellationTokenSource? _streamingCts;

    /// <summary>
    /// Threshold for enabling virtualization. Messages lists smaller than this render normally.
    /// </summary>
    private const int VirtualizationThreshold = 50;

    /// <summary>
    /// Record type for virtualization items.
    /// </summary>
    private record MessageWithIndex(Services.ChatMessage Message, int Index);

    /// <summary>
    /// Get indexed message list for virtualization.
    /// </summary>
    private List<MessageWithIndex> GetMessagesWithIndex() =>
        ChatService.Messages.Select((m, i) => new MessageWithIndex(m, i)).ToList();

    protected override void OnInitialized()
    {
        ChatService.MessagesChanged += OnMessagesChanged;
        ChatService.MessageStreaming += OnMessageStreaming;
    }

    private void OnMessagesChanged()
    {
        InvokeAsync(async () =>
        {
            StateHasChanged();
            await ScrollToBottomAsync();
        });
    }

    private void OnMessageStreaming(Services.ChatMessage message)
    {
        InvokeAsync(async () =>
        {
            StateHasChanged();
            await ScrollToBottomAsync();
        });
    }

    private async Task HandleSendMessage(string message)
    {
        ChatService.AddUserMessage(message);

        _streamingCts = new CancellationTokenSource();

        try
        {
            await ChatService.StreamAssistantResponseAsync(message, _streamingCts.Token);
        }
        catch (OperationCanceledException)
        {
            // User cancelled
        }
        finally
        {
            _streamingCts?.Dispose();
            _streamingCts = null;
        }
    }

    private async Task ScrollToBottomAsync()
    {
        try
        {
            // Scroll the messages container to bottom
            await JSRuntime.InvokeVoidAsync(
                "eval",
                "document.querySelector('.chat-messages')?.scrollTo({top: document.querySelector('.chat-messages')?.scrollHeight, behavior: 'smooth'})");
        }
        catch
        {
            // Ignore JS errors
        }
    }

    public void CancelStreaming()
    {
        _streamingCts?.Cancel();
    }

    public void Dispose()
    {
        ChatService.MessagesChanged -= OnMessagesChanged;
        ChatService.MessageStreaming -= OnMessageStreaming;
        _streamingCts?.Cancel();
        _streamingCts?.Dispose();
    }
}

<style>
    .chat-panel {
        display: flex;
        flex-direction: column;
        height: 100%;
        background: var(--background-base);
    }

    .chat-messages {
        flex: 1;
        overflow-y: auto;
        padding: 16px 0;
    }

    .chat-empty-state {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        height: 100%;
        padding: 24px;
        color: var(--text-weak);
    }

    .text-center {
        text-align: center;
    }

    .text-text-base {
        color: var(--text-base);
    }

    .text-text-weaker {
        color: var(--text-weaker);
    }
</style>
